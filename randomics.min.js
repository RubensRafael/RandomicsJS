class Randomic{basic(e,t,o=!1){return Math.floor(Math.random()*(t-e+(o?1:0)))+e}choice(e,t=1,o=!0){if(t<2)return e[this.basic(0,e.length)];if(t>=2&&o){let o=[];for(let s=0;s<t;s++)o.push(e[this.basic(0,e.length)]);return o}if(t>=2&&!o&&e.length>=t){let o=[];for(;o.length<t;){let t=e[this.basic(0,e.length)];-1==o.indexOf(t)?o.push(t):o.length}return o}return console.log("A tidade de resultados é maior do que o tamanho da sua coleção.",'Nessas condições o "repeat == false", gera um loop infinito')}choices(e,t,o=1,s=!0){if(e.length===t.length){let n=[];return t.map((function(t,o){for(let s=0;s<t;s++)n.push(e[o])})),o<2?n[this.basic(0,n.length)]:o>=2&&s?this.choice(n,o):o>=2&&!s&&e.length>=o?this.choice(n,o,!1):console.log("A tidade de resultados é maior do que o tamanho da sua coleção.",'Nessas condições o "repeat == false", gera um loop infinito')}return console.log("tamanho da coleção e dos pesos é diferente!")}shuflle(e){let t=e,o=t.length,s=[];for(;s.length<o;){let e=t.splice(this.basic(0,t.length),1)[0];s.push(e)}return s}probs(e){let t,o=[];return e.map((e=>o.push([e,0]))),e.map((function(s){t=e.indexOf(s),o[t][1]+=1})),o.map(((t,s)=>t[1]>0?t[1]=t[1]/e.length:o.splice(s,1))),o}};
